
import { useState, useCallback } from 'react';
import { usePayrollUnified } from './usePayrollUnified';
import { useToast } from '@/hooks/use-toast';
import { HistoryServiceAleluya } from '@/services/HistoryServiceAleluya';
import { PayrollLiquidationService } from '@/services/PayrollLiquidationService';
import { PayrollValidationService, PayrollValidationResults } from '@/services/PayrollValidationService';
import { PayrollReopenService } from '@/services/PayrollReopenService';
import { LiquidationStep } from '@/components/payroll/liquidation/PayrollProgressIndicator';
import { PayrollAtomicLiquidationService } from '@/services/PayrollAtomicLiquidationService';
import { PayrollExhaustiveValidationService, ValidationResult } from '@/services/PayrollExhaustiveValidationService';

export const usePayrollLiquidationSimplified = (companyId: string) => {
  const { toast } = useToast();
  const payrollHook = usePayrollUnified(companyId);
  const [isRepairing, setIsRepairing] = useState(false);
  
  // ‚úÖ NUEVOS ESTADOS PARA MEJORAS
  const [validationResults, setValidationResults] = useState<PayrollValidationResults | null>(null);
  const [exhaustiveValidationResults, setExhaustiveValidationResults] = useState<ValidationResult | null>(null);
  const [isValidating, setIsValidating] = useState(false);
  const [liquidationStep, setLiquidationStep] = useState<LiquidationStep>('validating');
  const [liquidationProgress, setLiquidationProgress] = useState(0);
  const [processedEmployees, setProcessedEmployees] = useState(0);
  const [liquidationErrors, setLiquidationErrors] = useState<string[]>([]);
  const [showProgress, setShowProgress] = useState(false);
  const [autoSendEmails, setAutoSendEmails] = useState(true);
  const [canRollback, setCanRollback] = useState(false);
  const [useAtomicLiquidation, setUseAtomicLiquidation] = useState(true);
  const [useExhaustiveValidation, setUseExhaustiveValidation] = useState(true);

  const loadEmployees = useCallback(async (
    startDate: string,
    endDate: string
  ) => {
    try {
      console.log('üë• Loading employees for payroll liquidation...');
      
      await payrollHook.loadEmployees(startDate, endDate);
      
      console.log('‚úÖ Employees loaded successfully');
      
      toast({
        title: "‚úÖ Empleados Cargados",
        description: "Empleados listos para liquidaci√≥n",
        className: "border-green-200 bg-green-50"
      });
      
      return true;

    } catch (error) {
      console.error('‚ùå Error loading employees:', error);
      
      toast({
        title: "‚ùå Error",
        description: "Error al cargar empleados para liquidaci√≥n",
        variant: "destructive"
      });
      
      throw error;
    }
  }, [companyId, payrollHook, toast]);

  // ‚úÖ NUEVA FUNCI√ìN: Validar per√≠odo antes de liquidar
  const validatePeriod = useCallback(async (
    startDate: string,
    endDate: string
  ) => {
    if (!payrollHook.currentPeriodId) {
      throw new Error('No hay per√≠odo activo para validar');
    }

    setIsValidating(true);
    try {
      console.log('üîç Validando per√≠odo para liquidaci√≥n...');
      
      const results = await PayrollValidationService.validatePayrollPeriod(
        payrollHook.employees,
        payrollHook.currentPeriodId,
        startDate,
        endDate
      );
      
      setValidationResults(results);
      
      if (results.canProceed) {
        toast({
          title: "‚úÖ Validaci√≥n Exitosa",
          description: "El per√≠odo est√° listo para liquidar",
          className: "border-green-200 bg-green-50"
        });
      } else {
        toast({
          title: "‚ö†Ô∏è Errores de Validaci√≥n",
          description: "Se encontraron errores que deben corregirse antes de liquidar",
          variant: "destructive"
        });
      }
      
      return results;
      
    } catch (error) {
      console.error('‚ùå Error en validaci√≥n:', error);
      toast({
        title: "‚ùå Error en Validaci√≥n",
        description: "Error al validar el per√≠odo",
        variant: "destructive"
      });
      throw error;
    } finally {
      setIsValidating(false);
    }
  }, [payrollHook.employees, payrollHook.currentPeriodId, toast]);

  // ‚úÖ NUEVA FUNCI√ìN: Validaci√≥n exhaustiva
  const performExhaustiveValidation = useCallback(async () => {
    if (!payrollHook.currentPeriodId || !companyId) {
      throw new Error('No hay per√≠odo o empresa para validar');
    }

    setIsValidating(true);
    try {
      console.log('üîç Ejecutando validaci√≥n exhaustiva...');
      
      const results = await PayrollExhaustiveValidationService.validateForLiquidation(
        payrollHook.currentPeriodId,
        companyId
      );
      
      setExhaustiveValidationResults(results);
      
      if (results.canProceed) {
        toast({
          title: "‚úÖ Validaci√≥n Exhaustiva Exitosa",
          description: `Score: ${results.score}/100 - Listo para liquidar`,
          className: "border-green-200 bg-green-50"
        });
      } else {
        toast({
          title: "‚ö†Ô∏è Validaci√≥n Exhaustiva Fall√≥",
          description: `Score: ${results.score}/100 - ${results.mustRepair.length} errores cr√≠ticos`,
          variant: "destructive"
        });
      }
      
      return results;
      
    } catch (error) {
      console.error('‚ùå Error en validaci√≥n exhaustiva:', error);
      toast({
        title: "‚ùå Error en Validaci√≥n Exhaustiva",
        description: "Error al validar el per√≠odo",
        variant: "destructive"
      });
      throw error;
    } finally {
      setIsValidating(false);
    }
  }, [payrollHook.currentPeriodId, companyId, toast]);

  // ‚úÖ NUEVA FUNCI√ìN: Reparaci√≥n autom√°tica
  const autoRepairValidationIssues = useCallback(async () => {
    if (!exhaustiveValidationResults) {
      throw new Error('No hay resultados de validaci√≥n para reparar');
    }

    try {
      console.log('üîß Iniciando reparaci√≥n autom√°tica...');
      
      const repairResult = await PayrollExhaustiveValidationService.autoRepairIssues(
        exhaustiveValidationResults
      );
      
      if (repairResult.success) {
        toast({
          title: "‚úÖ Reparaci√≥n Autom√°tica Exitosa",
          description: `Se repararon ${repairResult.repairedCount} problemas`,
          className: "border-green-200 bg-green-50"
        });
        
        // Re-validar despu√©s de la reparaci√≥n
        await performExhaustiveValidation();
      } else {
        toast({
          title: "‚ö†Ô∏è Reparaci√≥n Parcial",
          description: `Se repararon ${repairResult.repairedCount} de ${exhaustiveValidationResults.mustRepair.length} problemas`,
          variant: "destructive"
        });
      }
      
      return repairResult;
      
    } catch (error) {
      console.error('‚ùå Error en reparaci√≥n autom√°tica:', error);
      toast({
        title: "‚ùå Error en Reparaci√≥n",
        description: "No se pudo completar la reparaci√≥n autom√°tica",
        variant: "destructive"
      });
      throw error;
    }
  }, [exhaustiveValidationResults, performExhaustiveValidation, toast]);

  const liquidatePayroll = useCallback(async (
    startDate: string,
    endDate: string,
    isReliquidation = false
  ) => {
    // ===== TRAZA TEMPORAL SIMPLIFIED =====
    const simplifiedTraceId = `simplified_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
    console.log(`üîç [SIMPLIFIED-${simplifiedTraceId}] INICIANDO LIQUIDACI√ìN SIMPLIFICADA`, {
      isReliquidation: isReliquidation,
      startDate: startDate,
      endDate: endDate,
      currentPeriodId: payrollHook.currentPeriodId,
      companyId: companyId,
      employeesCount: payrollHook.employees.length,
      timestamp: new Date().toISOString()
    });

    try {
      setShowProgress(true);
      setLiquidationErrors([]);
      setProcessedEmployees(0);
      setCanRollback(false);

      // ===== USAR LIQUIDACI√ìN AT√ìMICA SI EST√Å HABILITADA =====
      if (useAtomicLiquidation && payrollHook.currentPeriodId) {
        console.log(`üîÑ [ATOMIC-${simplifiedTraceId}] USANDO LIQUIDACI√ìN AT√ìMICA`);
        
        setLiquidationStep('validating');
        setLiquidationProgress(20);
        
        const atomicResult = await PayrollAtomicLiquidationService.executeLiquidation(
          payrollHook.currentPeriodId,
          companyId,
          'current-user-id', // TODO: Obtener user ID real
          {
            generateVouchers: true,
            sendEmails: autoSendEmails,
            validateExhaustively: useExhaustiveValidation
          }
        );

        if (atomicResult.success) {
          setLiquidationStep('completed');
          setLiquidationProgress(100);
          setProcessedEmployees(atomicResult.employeesProcessed);
          
          toast({
            title: "‚úÖ Liquidaci√≥n At√≥mica Completada",
            description: `${atomicResult.employeesProcessed} empleados procesados con ${atomicResult.vouchersGenerated} comprobantes`,
            className: "border-green-200 bg-green-50"
          });
          
          setTimeout(() => setShowProgress(false), 3000);
          return;
        } else {
          setLiquidationStep('error');
          setLiquidationErrors([atomicResult.error || 'Error en liquidaci√≥n at√≥mica']);
          
          toast({
            title: atomicResult.rollbackPerformed ? "‚ö†Ô∏è Liquidaci√≥n Fall√≥ - Rollback Ejecutado" : "‚ùå Liquidaci√≥n Fall√≥",
            description: atomicResult.error || 'Error desconocido en liquidaci√≥n at√≥mica',
            variant: "destructive"
          });
          
          throw new Error(atomicResult.error || 'Error en liquidaci√≥n at√≥mica');
        }
      }
      
      // ===== LIQUIDACI√ìN TRADICIONAL (FALLBACK) =====
      console.log(`üîÑ [LEGACY-${simplifiedTraceId}] USANDO LIQUIDACI√ìN TRADICIONAL`);
      
      // Paso 1: Validaci√≥n final y verificaci√≥n de estado
      setLiquidationStep('validating');
      setLiquidationProgress(10);
      
      console.log(`üîç [SIMPLIFIED-${simplifiedTraceId}] PASO 1: Validaci√≥n y verificaci√≥n de estado`);
      
      if (payrollHook.currentPeriodId && companyId) {
        const validationStart = performance.now();
        console.log(`üîç [SIMPLIFIED-${simplifiedTraceId}] Ejecutando validaci√≥n pre-liquidaci√≥n...`);
        
        const validation = await PayrollValidationService.validatePreLiquidation(
          payrollHook.currentPeriodId,
          companyId
        );
        
        const validationDuration = performance.now() - validationStart;
        console.log(`üîç [SIMPLIFIED-${simplifiedTraceId}] VALIDACI√ìN RESPONSE:`, {
          validation: validation,
          duracion: `${validationDuration.toFixed(2)}ms`,
          issuesCount: validation.issues.length
        });
        
        // Si el per√≠odo ya est√° liquidado y no es re-liquidaci√≥n, lanzar error espec√≠fico
        const isAlreadyLiquidated = validation.issues.some(
          issue => issue.type === 'period_already_liquidated'
        );
        
        console.log(`üîç [SIMPLIFIED-${simplifiedTraceId}] Estado de liquidaci√≥n:`, {
          isAlreadyLiquidated: isAlreadyLiquidated,
          isReliquidation: isReliquidation
        });
        
        if (isAlreadyLiquidated && !isReliquidation) {
          console.log(`üîç [SIMPLIFIED-${simplifiedTraceId}] ‚ùå Per√≠odo ya liquidado - lanzando error espec√≠fico`);
          throw new Error('PERIOD_ALREADY_LIQUIDATED');
        }
        
        // Si es re-liquidaci√≥n, reabrir el per√≠odo primero
        if (isReliquidation && isAlreadyLiquidated) {
          console.log(`üîç [SIMPLIFIED-${simplifiedTraceId}] üîÑ Re-abriendo per√≠odo para re-liquidaci√≥n...`);
          await PayrollReopenService.reopenPayrollPeriod(payrollHook.currentPeriodId);
          console.log(`üîç [SIMPLIFIED-${simplifiedTraceId}] ‚úÖ Per√≠odo reabierto exitosamente`);
        }
      }
      
      await new Promise(resolve => setTimeout(resolve, 500)); // UX delay
      
      // Paso 2: C√°lculos
      setLiquidationStep('calculating');
      setLiquidationProgress(25);
      
      console.log(`üîç [SIMPLIFIED-${simplifiedTraceId}] PASO 2: Ejecutando c√°lculos principales...`);
      const calculationStart = performance.now();
      
      await payrollHook.liquidatePayroll(startDate, endDate);
      
      const calculationDuration = performance.now() - calculationStart;
      console.log(`üîç [SIMPLIFIED-${simplifiedTraceId}] ‚úÖ C√°lculos completados`, {
        duracion: `${calculationDuration.toFixed(2)}ms`,
        empleadosProcesados: payrollHook.employees.length
      });
      
      setProcessedEmployees(payrollHook.employees.length);
      
      // Paso 3: Generar comprobantes
      setLiquidationStep('generating_vouchers');
      setLiquidationProgress(60);
      await new Promise(resolve => setTimeout(resolve, 1000)); // Simular generaci√≥n
      
      // Paso 4: Enviar emails (si est√° habilitado)
      if (autoSendEmails) {
        setLiquidationStep('sending_emails');
        setLiquidationProgress(80);
        await new Promise(resolve => setTimeout(resolve, 1500)); // Simular env√≠o
      }
      
      // Paso 5: Sincronizaci√≥n y finalizaci√≥n
      setLiquidationStep('finalizing');
      setLiquidationProgress(90);
      
      if (payrollHook.currentPeriodId) {
        console.log('üîÑ Ejecutando sincronizaci√≥n post-liquidaci√≥n...');
        
        try {
          await HistoryServiceAleluya.consolidatePayrollWithNovedades(payrollHook.currentPeriodId);
          console.log('‚úÖ Novedades consolidadas');
          
          await HistoryServiceAleluya.updatePeriodTotals(payrollHook.currentPeriodId);
          console.log('‚úÖ Totales actualizados');
          
        } catch (syncError) {
          console.error('‚ùå Error en sincronizaci√≥n:', syncError);
          setLiquidationErrors(prev => [...prev, 'Error en sincronizaci√≥n de datos']);
          
          try {
            await HistoryServiceAleluya.repairPeriodSync(payrollHook.currentPeriodId);
            console.log('‚úÖ Reparaci√≥n de emergencia exitosa');
          } catch (repairError) {
            console.error('‚ùå Error en reparaci√≥n de emergencia:', repairError);
            setLiquidationErrors(prev => [...prev, 'Error en reparaci√≥n de emergencia']);
          }
        }
      }
      
      // Completado
      setLiquidationStep('completed');
      setLiquidationProgress(100);
      setCanRollback(true);
      
      toast({
        title: "‚úÖ Liquidaci√≥n Completada",
        description: `N√≥mina liquidada exitosamente para ${payrollHook.employees.length} empleados`,
        className: "border-green-200 bg-green-50"
      });
      
      // Ocultar progreso despu√©s de 3 segundos
      setTimeout(() => setShowProgress(false), 3000);
      
    } catch (error: any) {
      console.error(`üîç [SIMPLIFIED-${simplifiedTraceId}] ‚ùå ERROR EN LIQUIDACI√ìN SIMPLIFICADA:`, {
        error: error,
        message: error.message,
        stack: error.stack,
        isReliquidation: isReliquidation,
        currentStep: liquidationStep,
        currentProgress: liquidationProgress
      });
      
      setLiquidationStep('error');
      
      // Manejar error espec√≠fico de per√≠odo ya liquidado
      if (error.message === 'PERIOD_ALREADY_LIQUIDATED') {
        console.log(`üîç [SIMPLIFIED-${simplifiedTraceId}] ‚ö†Ô∏è Error espec√≠fico: Per√≠odo ya liquidado`);
        setLiquidationErrors(prev => [...prev, 'El per√≠odo ya fue liquidado anteriormente']);
        toast({
          title: "‚ö†Ô∏è Per√≠odo Ya Liquidado",
          description: "Este per√≠odo ya fue liquidado. Use la opci√≥n de re-liquidar si es necesario.",
          variant: "destructive"
        });
      } else {
        console.log(`üîç [SIMPLIFIED-${simplifiedTraceId}] ‚ùå Error general en liquidaci√≥n`);
        setLiquidationErrors(prev => [...prev, 'Error general en liquidaci√≥n']);
        toast({
          title: "‚ùå Error en Liquidaci√≥n",
          description: "Error al liquidar n√≥mina",
          variant: "destructive"
        });
      }
      
      throw error;
    }
  }, [payrollHook, toast, autoSendEmails, companyId]);

  // ‚úÖ NUEVA FUNCI√ìN: Rollback de liquidaci√≥n
  const rollbackLiquidation = useCallback(async () => {
    if (!payrollHook.currentPeriodId || !canRollback) {
      throw new Error('No se puede realizar rollback en este momento');
    }

    try {
      console.log('üîÑ Iniciando rollback de liquidaci√≥n...');
      
      // TODO: Implementar l√≥gica de rollback
      // - Cambiar estado del per√≠odo de 'cerrado' a 'borrador'
      // - Eliminar comprobantes generados
      // - Restaurar estados anteriores
      
      toast({
        title: "‚úÖ Rollback Completado",
        description: "La liquidaci√≥n ha sido revertida exitosamente",
        className: "border-blue-200 bg-blue-50"
      });
      
      setCanRollback(false);
      
    } catch (error) {
      console.error('‚ùå Error en rollback:', error);
      toast({
        title: "‚ùå Error en Rollback",
        description: "No se pudo revertir la liquidaci√≥n",
        variant: "destructive"
      });
      throw error;
    }
  }, [payrollHook.currentPeriodId, canRollback, toast]);

  const repairPeriodSync = useCallback(async (periodId: string) => {
    setIsRepairing(true);
    try {
      console.log(`üîß Reparando sincronizaci√≥n para per√≠odo: ${periodId}`);
      
      await HistoryServiceAleluya.repairPeriodSync(periodId);
      
      toast({
        title: "‚úÖ Sincronizaci√≥n Reparada",
        description: "El per√≠odo ha sido sincronizado correctamente",
        className: "border-green-200 bg-green-50"
      });
      
    } catch (error) {
      console.error('‚ùå Error reparando sincronizaci√≥n:', error);
      
      toast({
        title: "‚ùå Error en Reparaci√≥n",
        description: "No se pudo reparar la sincronizaci√≥n",
        variant: "destructive"
      });
      
      throw error;
    } finally {
      setIsRepairing(false);
    }
  }, [toast]);

  const repairAllDesynchronizedPeriods = useCallback(async () => {
    setIsRepairing(true);
    try {
      console.log('üîß Detectando y reparando per√≠odos desincronizados...');
      
      const repairedCount = await HistoryServiceAleluya.repairAllDesynchronizedPeriods();
      
      if (repairedCount > 0) {
        toast({
          title: "‚úÖ Reparaci√≥n Masiva Completada",
          description: `Se repararon ${repairedCount} per√≠odos desincronizados`,
          className: "border-green-200 bg-green-50"
        });
      } else {
        toast({
          title: "‚úÖ Sistema Sincronizado",
          description: "No se encontraron per√≠odos desincronizados",
          className: "border-blue-200 bg-blue-50"
        });
      }
      
      return repairedCount;
      
    } catch (error) {
      console.error('‚ùå Error en reparaci√≥n masiva:', error);
      
      toast({
        title: "‚ùå Error en Reparaci√≥n Masiva",
        description: "No se pudo completar la reparaci√≥n masiva",
        variant: "destructive"
      });
      
      throw error;
    } finally {
      setIsRepairing(false);
    }
  }, [toast]);

  return {
    ...payrollHook,
    loadEmployees,
    liquidatePayroll,
    repairPeriodSync,
    repairAllDesynchronizedPeriods,
    isRepairing,
    canProceedWithLiquidation: payrollHook.employees.length > 0,
    isLoadingEmployees: payrollHook.isLoading,
    isAutoSaving: false,
    lastAutoSaveTime: undefined,
    isRemovingEmployee: false,
    updateEmployeeCalculationsInDB: payrollHook.updateEmployeeCalculationsInDB,
    
    // ‚úÖ NUEVAS FUNCIONALIDADES
    validatePeriod,
    rollbackLiquidation,
    validationResults,
    isValidating,
    liquidationStep,
    liquidationProgress,
    processedEmployees,
    liquidationErrors,
    showProgress,
    autoSendEmails,
    setAutoSendEmails,
    canRollback,
    
    // ‚úÖ FUNCIONALIDADES CLASE MUNDIAL
    performExhaustiveValidation,
    autoRepairValidationIssues,
    exhaustiveValidationResults,
    useAtomicLiquidation,
    setUseAtomicLiquidation,
    useExhaustiveValidation,
    setUseExhaustiveValidation
  };
};

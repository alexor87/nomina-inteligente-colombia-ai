
import { useState, useCallback } from 'react';
import { usePayrollUnified } from './usePayrollUnified';
import { useToast } from '@/hooks/use-toast';
import { HistoryServiceAleluya } from '@/services/HistoryServiceAleluya';
import { PayrollLiquidationService } from '@/services/PayrollLiquidationService';
import { PayrollValidationService, PayrollValidationResults } from '@/services/PayrollValidationService';
import { LiquidationStep } from '@/components/payroll/liquidation/PayrollProgressIndicator';

export const usePayrollLiquidationSimplified = (companyId: string) => {
  const { toast } = useToast();
  const payrollHook = usePayrollUnified(companyId);
  const [isRepairing, setIsRepairing] = useState(false);
  
  // ‚úÖ NUEVOS ESTADOS PARA MEJORAS
  const [validationResults, setValidationResults] = useState<PayrollValidationResults | null>(null);
  const [isValidating, setIsValidating] = useState(false);
  const [liquidationStep, setLiquidationStep] = useState<LiquidationStep>('validating');
  const [liquidationProgress, setLiquidationProgress] = useState(0);
  const [processedEmployees, setProcessedEmployees] = useState(0);
  const [liquidationErrors, setLiquidationErrors] = useState<string[]>([]);
  const [showProgress, setShowProgress] = useState(false);
  const [autoSendEmails, setAutoSendEmails] = useState(true);
  const [canRollback, setCanRollback] = useState(false);

  const loadEmployees = useCallback(async (
    startDate: string,
    endDate: string
  ) => {
    try {
      console.log('üë• Loading employees for payroll liquidation...');
      
      await payrollHook.loadEmployees(startDate, endDate);
      
      console.log('‚úÖ Employees loaded successfully');
      
      toast({
        title: "‚úÖ Empleados Cargados",
        description: "Empleados listos para liquidaci√≥n",
        className: "border-green-200 bg-green-50"
      });
      
      return true;

    } catch (error) {
      console.error('‚ùå Error loading employees:', error);
      
      toast({
        title: "‚ùå Error",
        description: "Error al cargar empleados para liquidaci√≥n",
        variant: "destructive"
      });
      
      throw error;
    }
  }, [companyId, payrollHook, toast]);

  // ‚úÖ NUEVA FUNCI√ìN: Validar per√≠odo antes de liquidar
  const validatePeriod = useCallback(async (
    startDate: string,
    endDate: string
  ) => {
    if (!payrollHook.currentPeriodId) {
      throw new Error('No hay per√≠odo activo para validar');
    }

    setIsValidating(true);
    try {
      console.log('üîç Validando per√≠odo para liquidaci√≥n...');
      
      const results = await PayrollValidationService.validatePayrollPeriod(
        payrollHook.employees,
        payrollHook.currentPeriodId,
        startDate,
        endDate
      );
      
      setValidationResults(results);
      
      if (results.canProceed) {
        toast({
          title: "‚úÖ Validaci√≥n Exitosa",
          description: "El per√≠odo est√° listo para liquidar",
          className: "border-green-200 bg-green-50"
        });
      } else {
        toast({
          title: "‚ö†Ô∏è Errores de Validaci√≥n",
          description: "Se encontraron errores que deben corregirse antes de liquidar",
          variant: "destructive"
        });
      }
      
      return results;
      
    } catch (error) {
      console.error('‚ùå Error en validaci√≥n:', error);
      toast({
        title: "‚ùå Error en Validaci√≥n",
        description: "Error al validar el per√≠odo",
        variant: "destructive"
      });
      throw error;
    } finally {
      setIsValidating(false);
    }
  }, [payrollHook.employees, payrollHook.currentPeriodId, toast]);

  const liquidatePayroll = useCallback(async (
    startDate: string,
    endDate: string
  ) => {
    try {
      console.log('üîÑ Iniciando liquidaci√≥n mejorada...');
      setShowProgress(true);
      setLiquidationErrors([]);
      setProcessedEmployees(0);
      setCanRollback(false);
      
      // Paso 1: Validaci√≥n final
      setLiquidationStep('validating');
      setLiquidationProgress(10);
      await new Promise(resolve => setTimeout(resolve, 500)); // UX delay
      
      // Paso 2: C√°lculos
      setLiquidationStep('calculating');
      setLiquidationProgress(25);
      await payrollHook.liquidatePayroll(startDate, endDate);
      setProcessedEmployees(payrollHook.employees.length);
      
      // Paso 3: Generar comprobantes
      setLiquidationStep('generating_vouchers');
      setLiquidationProgress(60);
      await new Promise(resolve => setTimeout(resolve, 1000)); // Simular generaci√≥n
      
      // Paso 4: Enviar emails (si est√° habilitado)
      if (autoSendEmails) {
        setLiquidationStep('sending_emails');
        setLiquidationProgress(80);
        await new Promise(resolve => setTimeout(resolve, 1500)); // Simular env√≠o
      }
      
      // Paso 5: Sincronizaci√≥n y finalizaci√≥n
      setLiquidationStep('finalizing');
      setLiquidationProgress(90);
      
      if (payrollHook.currentPeriodId) {
        console.log('üîÑ Ejecutando sincronizaci√≥n post-liquidaci√≥n...');
        
        try {
          await HistoryServiceAleluya.consolidatePayrollWithNovedades(payrollHook.currentPeriodId);
          console.log('‚úÖ Novedades consolidadas');
          
          await HistoryServiceAleluya.updatePeriodTotals(payrollHook.currentPeriodId);
          console.log('‚úÖ Totales actualizados');
          
        } catch (syncError) {
          console.error('‚ùå Error en sincronizaci√≥n:', syncError);
          setLiquidationErrors(prev => [...prev, 'Error en sincronizaci√≥n de datos']);
          
          try {
            await HistoryServiceAleluya.repairPeriodSync(payrollHook.currentPeriodId);
            console.log('‚úÖ Reparaci√≥n de emergencia exitosa');
          } catch (repairError) {
            console.error('‚ùå Error en reparaci√≥n de emergencia:', repairError);
            setLiquidationErrors(prev => [...prev, 'Error en reparaci√≥n de emergencia']);
          }
        }
      }
      
      // Completado
      setLiquidationStep('completed');
      setLiquidationProgress(100);
      setCanRollback(true);
      
      toast({
        title: "‚úÖ Liquidaci√≥n Completada",
        description: `N√≥mina liquidada exitosamente para ${payrollHook.employees.length} empleados`,
        className: "border-green-200 bg-green-50"
      });
      
      // Ocultar progreso despu√©s de 3 segundos
      setTimeout(() => setShowProgress(false), 3000);
      
    } catch (error) {
      console.error('‚ùå Error en liquidaci√≥n:', error);
      setLiquidationStep('error');
      setLiquidationErrors(prev => [...prev, 'Error general en liquidaci√≥n']);
      
      toast({
        title: "‚ùå Error en Liquidaci√≥n",
        description: "Error al liquidar n√≥mina",
        variant: "destructive"
      });
      
      throw error;
    }
  }, [payrollHook, toast, autoSendEmails]);

  // ‚úÖ NUEVA FUNCI√ìN: Rollback de liquidaci√≥n
  const rollbackLiquidation = useCallback(async () => {
    if (!payrollHook.currentPeriodId || !canRollback) {
      throw new Error('No se puede realizar rollback en este momento');
    }

    try {
      console.log('üîÑ Iniciando rollback de liquidaci√≥n...');
      
      // TODO: Implementar l√≥gica de rollback
      // - Cambiar estado del per√≠odo de 'cerrado' a 'borrador'
      // - Eliminar comprobantes generados
      // - Restaurar estados anteriores
      
      toast({
        title: "‚úÖ Rollback Completado",
        description: "La liquidaci√≥n ha sido revertida exitosamente",
        className: "border-blue-200 bg-blue-50"
      });
      
      setCanRollback(false);
      
    } catch (error) {
      console.error('‚ùå Error en rollback:', error);
      toast({
        title: "‚ùå Error en Rollback",
        description: "No se pudo revertir la liquidaci√≥n",
        variant: "destructive"
      });
      throw error;
    }
  }, [payrollHook.currentPeriodId, canRollback, toast]);

  const repairPeriodSync = useCallback(async (periodId: string) => {
    setIsRepairing(true);
    try {
      console.log(`üîß Reparando sincronizaci√≥n para per√≠odo: ${periodId}`);
      
      await HistoryServiceAleluya.repairPeriodSync(periodId);
      
      toast({
        title: "‚úÖ Sincronizaci√≥n Reparada",
        description: "El per√≠odo ha sido sincronizado correctamente",
        className: "border-green-200 bg-green-50"
      });
      
    } catch (error) {
      console.error('‚ùå Error reparando sincronizaci√≥n:', error);
      
      toast({
        title: "‚ùå Error en Reparaci√≥n",
        description: "No se pudo reparar la sincronizaci√≥n",
        variant: "destructive"
      });
      
      throw error;
    } finally {
      setIsRepairing(false);
    }
  }, [toast]);

  const repairAllDesynchronizedPeriods = useCallback(async () => {
    setIsRepairing(true);
    try {
      console.log('üîß Detectando y reparando per√≠odos desincronizados...');
      
      const repairedCount = await HistoryServiceAleluya.repairAllDesynchronizedPeriods();
      
      if (repairedCount > 0) {
        toast({
          title: "‚úÖ Reparaci√≥n Masiva Completada",
          description: `Se repararon ${repairedCount} per√≠odos desincronizados`,
          className: "border-green-200 bg-green-50"
        });
      } else {
        toast({
          title: "‚úÖ Sistema Sincronizado",
          description: "No se encontraron per√≠odos desincronizados",
          className: "border-blue-200 bg-blue-50"
        });
      }
      
      return repairedCount;
      
    } catch (error) {
      console.error('‚ùå Error en reparaci√≥n masiva:', error);
      
      toast({
        title: "‚ùå Error en Reparaci√≥n Masiva",
        description: "No se pudo completar la reparaci√≥n masiva",
        variant: "destructive"
      });
      
      throw error;
    } finally {
      setIsRepairing(false);
    }
  }, [toast]);

  return {
    ...payrollHook,
    loadEmployees,
    liquidatePayroll,
    repairPeriodSync,
    repairAllDesynchronizedPeriods,
    isRepairing,
    canProceedWithLiquidation: payrollHook.employees.length > 0,
    isLoadingEmployees: payrollHook.isLoading,
    isAutoSaving: false,
    lastAutoSaveTime: undefined,
    isRemovingEmployee: false,
    updateEmployeeCalculationsInDB: payrollHook.updateEmployeeCalculationsInDB,
    
    // ‚úÖ NUEVAS FUNCIONALIDADES
    validatePeriod,
    rollbackLiquidation,
    validationResults,
    isValidating,
    liquidationStep,
    liquidationProgress,
    processedEmployees,
    liquidationErrors,
    showProgress,
    autoSendEmails,
    setAutoSendEmails,
    canRollback
  };
};
